{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Ignyx","text":"<p>Ignite your API. Built in Rust, runs in Python.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>Ignyx is designed to be genuinely faster than existing frameworks by optimizing the entire request lifecycle.</p> Endpoint Ignyx FastAPI Speedup <code>/plaintext</code> 53,886 req/s 6,193 req/s 8.70x <code>/users/{id}</code> 48,988 req/s 5,597 req/s 8.75x <code>/users</code> (JSON) 44,178 req/s 5,200 req/s 8.49x"},{"location":"dependency_injection/","title":"Dependency Injection","text":"<p>Dependency Injection (DI) is a powerful pattern in Ignyx that allows you to declare dependencies for your route handlers. Ignyx then takes care of resolving these dependencies, providing you with the necessary objects automatically.</p>"},{"location":"dependency_injection/#overview","title":"Overview","text":"<p>The <code>Depends()</code> pattern allows you to write reusable logic that can be shared across multiple routes. This is useful for: - Authentication and authorization - Database connection management - Shared configuration - Request pre-processing</p> <p>When you use <code>Depends()</code>, Ignyx calls the dependency for you and passes the result to your handler.</p>"},{"location":"dependency_injection/#basic-example","title":"Basic Example","text":"<p>Here's a simple example of using <code>Depends()</code> to extract a token from a header.</p> <pre><code>from ignyx import Ignyx, Depends, Request\n\napp = Ignyx()\n\ndef get_current_user(request: Request):\n    token = request.headers.get(\"Authorization\")\n    if not token:\n        # In a real app, you would raise an HTTPException here\n        return \"Anonymous\"\n    return {\"id\": 1, \"name\": \"Saketh\"}\n\n@app.get(\"/users/me\")\ndef read_current_user(user = Depends(get_current_user)):\n    return user\n</code></pre>"},{"location":"dependency_injection/#advanced-example-chained-dependencies","title":"Advanced Example: Chained Dependencies","text":"<p>Dependencies can also depend on other dependencies, allowing you to create complex authentication or data retrieval chains.</p> <pre><code>from ignyx import Ignyx, Depends, Request\n\napp = Ignyx()\n\ndef get_db():\n    return {\"session\": \"active_db_session\"}\n\ndef get_current_user(db = Depends(get_db)):\n    # Use db session to find user\n    return {\"id\": 1, \"username\": \"sakethdevx\"}\n\ndef get_active_user(user = Depends(get_current_user)):\n    if user.get(\"disabled\"):\n        raise HTTPException(400, \"User inactive\")\n    return user\n\n@app.get(\"/items\")\ndef read_items(user = Depends(get_active_user)):\n    return {\"user\": user, \"items\": [\"item1\", \"item2\"]}\n</code></pre>"},{"location":"dependency_injection/#generator-dependencies","title":"Generator Dependencies","text":"<p>Ignyx supports generator dependencies using <code>yield</code>. This is perfect for resources that need cleanup, such as database sessions or file handles.</p> <pre><code>def get_db():\n    db = DatabaseSession()\n    try:\n        yield db\n    finally:\n        db.close() # cleanup happens after route execution\n</code></pre>"},{"location":"dependency_injection/#testing","title":"Testing","text":"<p>You can easily override dependencies in your tests using the <code>dependency_overrides</code> attribute of the <code>Ignyx</code> app or <code>TestClient</code>.</p> <pre><code>from ignyx.testclient import TestClient\n\ndef override_get_current_user():\n    return {\"id\": 999, \"name\": \"Test User\"}\n\napp.dependency_overrides[get_current_user] = override_get_current_user\n\nclient = TestClient(app)\nresponse = client.get(\"/users/me\")\nassert response.json()[\"id\"] == 999\n</code></pre>"},{"location":"dependency_injection/#api-reference","title":"API Reference","text":""},{"location":"dependency_injection/#dependsdependency-use_cachetrue","title":"<code>Depends(dependency, use_cache=True)</code>","text":"<ul> <li><code>dependency</code>: A callable (function, class).</li> <li><code>use_cache</code>: If <code>True</code>, the result of the dependency is cached for the duration of a single request. If multiple routes or dependencies depend on the same callable, it will only be executed once per request.</li> </ul>"},{"location":"deployment/","title":"Deployment","text":"<p>Deploying an Ignyx application is straightforward because it doesn't require an external ASGI server like Uvicorn or Gunicorn. Ignyx handles its own concurrency using its high-performance Rust core powered by the Tokio runtime.</p>"},{"location":"deployment/#overview","title":"Overview","text":"<p>When you run an Ignyx application, you are starting a high-performance HTTP server that manages its own threads and event loops. You simply run your Python script, and it listens on the specified port.</p>"},{"location":"deployment/#docker","title":"Docker","text":"<p>Using Docker is the recommended way to deploy Ignyx for production. Here is a multi-stage build example that keeps the image small.</p> <pre><code># Use a lightweight Python base\nFROM python:3.12-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n# Set work directory\nWORKDIR /app\n\n# Install dependencies (ignyx requires a rust toolchain for install if not using a wheel)\n# but for a production image, we usually install from pypi\nRUN pip install --no-cache-dir ignyx pydantic\n\n# Copy project files\nCOPY . .\n\n# Expose port\nEXPOSE 8000\n\n# Run the application\nCMD [\"python\", \"main.py\"]\n</code></pre>"},{"location":"deployment/#systemd-linux","title":"systemd (Linux)","text":"<p>You can run Ignyx as a background service on a Linux server using systemd.</p> <p>Create <code>/etc/systemd/system/ignyx-app.service</code>:</p> <pre><code>[Unit]\nDescription=Ignyx API Application\nAfter=network.target\n\n[Service]\nUser=www-data\nGroup=www-data\nWorkingDirectory=/var/www/my-app\nEnvironment=\"PYTHONPATH=/var/www/my-app\"\nExecStart=/var/www/my-app/venv/bin/python main.py\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Then enable and start it:</p> <pre><code>sudo systemctl enable ignyx-app\nsudo systemctl start ignyx-app\n</code></pre>"},{"location":"deployment/#cloud-deployment","title":"Cloud Deployment","text":"<p>Because Ignyx is a standard Python application that listens on a port, it works flawlessly on all modern cloud platforms.</p>"},{"location":"deployment/#railway-render-flyio","title":"Railway / Render / Fly.io","text":"<p>Simply connect your GitHub repository. These platforms will detect your <code>requirements.txt</code> or <code>pyproject.toml</code>, install Ignyx, and run your start command (e.g., <code>python main.py</code>).</p>"},{"location":"deployment/#no-uvicorn-needed","title":"No Uvicorn Needed","text":"<p>Development and production deployment of Ignyx are identical.</p> <p>fastapi_app.py: <code>uvicorn app:app</code> (requires external process)</p> <p>ignyx_app.py: <code>python app.py</code> (server is built-in)</p> <p>The Rust core handles high-concurrency request parsing and dispatching far more efficiently than standard Python-based ASGI servers.</p>"},{"location":"error_handling/","title":"Error Handling","text":"<p>Handling errors gracefully is essential for a professional API. Ignyx provides built-in mechanisms for raising HTTP exceptions and registering custom error handlers for both HTTP statuses and generic Python exceptions.</p>"},{"location":"error_handling/#overview","title":"Overview","text":"<p>You can handle errors at two levels: 1. Implicitly: By raising an <code>HTTPException</code>. 2. Explicitly: By defining custom handlers with the <code>@app.exception_handler</code> decorator.</p>"},{"location":"error_handling/#raising-httpexception","title":"Raising HTTPException","text":"<p>The <code>HTTPException</code> class allows you to return an error response from anywhere in your code (including deep inside dependencies).</p> <pre><code>from ignyx import Ignyx, HTTPException\n\napp = Ignyx()\n\n@app.get(\"/items/{id}\")\ndef read_item(id: int):\n    if id not in database:\n        raise HTTPException(\n            status_code=404,\n            detail=f\"Item {id} not found\",\n            headers={\"X-Error\": \"Not Found\"}\n        )\n    return database[id]\n</code></pre>"},{"location":"error_handling/#custom-status-handlers","title":"Custom Status Handlers","text":"<p>You can override the default behavior for specific HTTP status codes.</p> <pre><code>from ignyx import Ignyx, JSONResponse\n\n@app.exception_handler(404)\ndef not_found_handler(request, exc):\n    return JSONResponse(\n        {\"error\": \"Resource Missing\", \"path\": request.path},\n        status_code=404\n    )\n</code></pre>"},{"location":"error_handling/#exception-type-handlers","title":"Exception Type Handlers","text":"<p>You can also register handlers for specific Python exception types. This is useful for catching errors from external libraries (like SQLAlchemy or Pydantic) and converting them into uniform API responses.</p> <pre><code>@app.exception_handler(ValueError)\ndef value_error_handler(request, exc):\n    return JSONResponse(\n        {\"error\": \"Value Error\", \"message\": str(exc)},\n        status_code=400\n    )\n</code></pre>"},{"location":"error_handling/#global-error-response-format","title":"Global Error Response Format","text":"<p>By default, Ignyx returns error responses in a standard JSON format:</p> <pre><code>{\n    \"detail\": \"Actual error message\"\n}\n</code></pre> <p>Validation errors use a more detailed structure inspired by Pydantic's error format.</p>"},{"location":"error_handling/#api-reference","title":"API Reference","text":""},{"location":"error_handling/#httpexceptionstatus_code-detailnone-headersnone","title":"<code>HTTPException(status_code, detail=None, headers=None)</code>","text":"<p>Exception class for returning HTTP errors.</p>"},{"location":"error_handling/#appexception_handlerstatus_code_or_type","title":"<code>@app.exception_handler(status_code_or_type)</code>","text":"<p>Decorator for registering custom error handling functions.</p>"},{"location":"lifespan/","title":"Lifespan Events","text":"<p>Lifespan events allow you to run logic at the beginning and end of your Ignyx application's lifecycle. This is perfect for managing resources that should exist for the entire duration of the server.</p>"},{"location":"lifespan/#overview","title":"Overview","text":"<p>Ignyx provides two main decorators for lifespan management: - <code>@app.on_startup</code>: Executed once when the server starts listening for requests. - <code>@app.on_shutdown</code>: Executed once when the server receives a shutdown signal.</p>"},{"location":"lifespan/#database-connections","title":"Database Connections","text":"<p>Use startup events to initialize database connection pools once, instead of per-request.</p> <pre><code>from ignyx import Ignyx\n\napp = Ignyx()\ndb_pool = None\n\n@app.on_startup\nasync def setup_db():\n    global db_pool\n    db_pool = await create_db_pool(\"postgres://...\")\n    print(\"Database connection established\")\n\n@app.on_shutdown\nasync def close_db():\n    await db_pool.close()\n    print(\"Database connection closed\")\n</code></pre>"},{"location":"lifespan/#application-state","title":"Application State","text":"<p>You can use <code>app.state</code> to store objects that need to be accessed by your dependencies and route handlers. <code>app.state</code> is a thread-safe <code>SimpleNamespace</code>.</p> <pre><code>@app.on_startup\ndef init_cache():\n    app.state.cache = RedisCache()\n\n@app.get(\"/items\")\ndef get_items():\n    # Access state in handlers\n    return app.state.cache.get(\"items\")\n</code></pre>"},{"location":"lifespan/#async-startup-handlers","title":"Async Startup Handlers","text":"<p>Ignyx supports both <code>def</code> and <code>async def</code> for lifespan handlers. If you use <code>async def</code>, Ignyx will run the task within the global event loop before the server starts accepting traffic.</p> <pre><code>@app.on_startup\nasync def warm_cache():\n    await perform_heavy_async_warmup()\n</code></pre>"},{"location":"lifespan/#api-reference","title":"API Reference","text":""},{"location":"lifespan/#appon_startup","title":"<code>@app.on_startup</code>","text":"<p>Decorator for functions to run on startup.</p>"},{"location":"lifespan/#appon_shutdown","title":"<code>@app.on_shutdown</code>","text":"<p>Decorator for functions to run on shutdown.</p>"},{"location":"lifespan/#appstate","title":"<code>app.state</code>","text":"<p>A storage object for application-wide data.</p>"},{"location":"middleware/","title":"Middleware","text":"<p>Middleware is a powerful way to intercept and process requests and responses globally in your Ignyx application. It allows you to add cross-cutting concerns like logging, authentication, CORS, and rate limiting.</p>"},{"location":"middleware/#overview","title":"Overview","text":"<p>The middleware lifecycle in Ignyx follows three main stages: 1. <code>before_request</code>: Executed before the request reaches the route handler. 2. <code>after_request</code>: Executed after the route handler has processed the request. 3. <code>on_error</code>: Executed if an exception occurs during request processing.</p>"},{"location":"middleware/#basic-example-custom-logging-middleware","title":"Basic Example: Custom Logging Middleware","text":"<p>You can create custom middleware by extending the <code>Middleware</code> base class.</p> <pre><code>from ignyx.middleware import Middleware\nimport time\n\nclass LoggingMiddleware(Middleware):\n    def before_request(self, request):\n        request.state.start_time = time.time()\n\n    def after_request(self, request, response):\n        process_time = time.time() - request.state.start_time\n        print(f\"{request.method} {request.path} completed in {process_time:.4f}s\")\n        response.headers[\"X-Process-Time\"] = str(process_time)\n        return response\n\napp.add_middleware(LoggingMiddleware)\n</code></pre>"},{"location":"middleware/#corsmiddleware","title":"CORSMiddleware","text":"<p>Ignyx provides a built-in <code>CORSMiddleware</code> to handle Cross-Origin Resource Sharing.</p> <pre><code>from ignyx.middleware import CORSMiddleware\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_methods=[\"GET\", \"POST\", \"PUT\", \"DELETE\"],\n    allow_headers=[\"Content-Type\", \"Authorization\"],\n    allow_credentials=True,\n    max_age=3600\n)\n</code></pre>"},{"location":"middleware/#parameters","title":"Parameters:","text":"<ul> <li><code>allow_origins</code>: List of allowed origins. Use <code>[\"*\"]</code> for all.</li> <li><code>allow_methods</code>: List of allowed HTTP methods.</li> <li><code>allow_headers</code>: List of allowed request headers.</li> <li><code>allow_credentials</code>: Whether to allow cookies in cross-origin requests.</li> <li><code>max_age</code>: Time in seconds to cache preflight responses.</li> </ul>"},{"location":"middleware/#ratelimitmiddleware","title":"RateLimitMiddleware","text":"<p>Protect your API from abuse with the <code>RateLimitMiddleware</code>.</p> <pre><code>from ignyx.middleware import RateLimitMiddleware\n\napp.add_middleware(\n    RateLimitMiddleware,\n    requests_per_window=100,\n    window_seconds=60\n)\n</code></pre> <p>This example limits clients to 100 requests per minute.</p>"},{"location":"middleware/#accesslogmiddleware","title":"AccessLogMiddleware","text":"<p>Standardize your application logs with <code>AccessLogMiddleware</code>.</p> <pre><code>from ignyx.middleware import AccessLogMiddleware\n\napp.add_middleware(AccessLogMiddleware, logger_name=\"ignyx.access\")\n</code></pre> <p>It logs request method, path, status code, and latency in a clean format.</p>"},{"location":"middleware/#writing-custom-middleware","title":"Writing Custom Middleware","text":"<p>To write your own middleware, inherit from <code>ignyx.middleware.Middleware</code> and override the lifecycle methods you need.</p> <pre><code>from ignyx.middleware import Middleware\n\nclass MyMiddleware(Middleware):\n    def __init__(self, some_config=None):\n        self.some_config = some_config\n\n    def before_request(self, request):\n        # Do something before handler\n        pass\n\n    def after_request(self, request, response):\n        # Do something after handler\n        return response\n\n    def on_error(self, request, error):\n        # Handle error\n        pass\n</code></pre>"},{"location":"middleware/#middleware-ordering","title":"Middleware Ordering","text":"<p>The order in which you call <code>app.add_middleware()</code> matters. Middleware added first will execute its <code>before_request</code> first, but its <code>after_request</code> will execute last (wrapping the inner layers).</p> <pre><code>app.add_middleware(MiddlewareA)\napp.add_middleware(MiddlewareB)\n\n# Execution Flow:\n# MiddlewareA.before -&gt; MiddlewareB.before -&gt; Handler -&gt; MiddlewareB.after -&gt; MiddlewareA.after\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Install Ignyx via pip:</p> <pre><code>pip install ignyx\n</code></pre> <p>Create a basic app:</p> <pre><code>from ignyx import Ignyx\napp = Ignyx()\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Ignited!\"}\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\", port=8000)\n</code></pre>"},{"location":"request/","title":"Request Object","text":"<p>The <code>Request</code> object represents the incoming HTTP request and provides access to all its components like headers, query parameters, path parameters, and the request body.</p>"},{"location":"request/#overview","title":"Overview","text":"<p>When a request hits your Ignyx application, a <code>Request</code> object is created. You can access it in your route handlers by type-hinting it in the function signature.</p>"},{"location":"request/#properties","title":"Properties","text":"<p>The <code>Request</code> object has the following properties:</p> <ul> <li><code>request.method</code>: The HTTP method (e.g., <code>\"GET\"</code>, <code>\"POST\"</code>).</li> <li><code>request.path</code>: The request URL path (e.g., <code>\"/users/me\"</code>).</li> <li><code>request.headers</code>: A case-insensitive dictionary of request headers.</li> <li><code>request.query_params</code>: A dictionary containing query string parameters.</li> <li><code>request.path_params</code>: A dictionary containing path parameters captured from the URL.</li> <li><code>request.cookies</code>: A dictionary containing cookies sent with the request.</li> <li><code>request.body</code>: The raw request body as bytes.</li> <li><code>request.client_addr</code>: The IP address of the client (if available).</li> </ul>"},{"location":"request/#headers","title":"Headers","text":"<p>Headers are accessed via a case-insensitive dictionary.</p> <pre><code>@app.get(\"/debug\")\ndef debug_headers(request: Request):\n    user_agent = request.headers.get(\"User-Agent\")\n    api_key = request.headers.get(\"X-API-Key\")\n    return {\"ua\": user_agent, \"key\": api_key}\n</code></pre>"},{"location":"request/#query-parameters","title":"Query Parameters","text":"<p>Query parameters are easily accessible and support basic type coercion.</p> <pre><code>@app.get(\"/search\")\ndef search(request: Request):\n    q = request.query_params.get(\"q\", \"\")\n    page = int(request.query_params.get(\"page\", 1))\n    return {\"query\": q, \"page\": page}\n</code></pre>"},{"location":"request/#body","title":"Body","text":"<p>Ignyx provides several ways to read the request body:</p> <pre><code>@app.post(\"/submit\")\nasync def submit(request: Request):\n    # Read raw bytes\n    raw_bytes = request.body\n\n    # Read as text\n    text = request.text()\n\n    # Read as parsed JSON\n    data = request.json()\n\n    return {\"received\": data}\n</code></pre>"},{"location":"request/#cookies","title":"Cookies","text":"<p>Cookies are parsed into a simple dictionary.</p> <pre><code>@app.get(\"/check-session\")\ndef check_session(request: Request):\n    session_id = request.cookies.get(\"session_id\")\n    return {\"session\": session_id}\n</code></pre>"},{"location":"request/#injecting-request","title":"Injecting Request","text":"<p>To use the <code>Request</code> object, simply add it to your handler parameters. Ignyx will automatically inject it.</p> <pre><code>from ignyx import Request\n\n@app.get(\"/\")\ndef home(request: Request):\n    return f\"Hello, your path is {request.path}\"\n</code></pre> <p>Note: You don't need to specify <code>Depends()</code> for the <code>Request</code> object; it is always available for injection by type alone.</p>"},{"location":"response/","title":"Response Classes","text":"<p>Ignyx provides a flexible way to return responses from your route handlers. Whether you want to return a simple dictionary, a custom response object, or a complex file download, Ignyx has you covered.</p>"},{"location":"response/#overview","title":"Overview","text":"<p>Ignyx automatically handles several return types from your handlers: - <code>dict</code> or <code>list</code>: Serialized to JSON. - <code>str</code>: Returned as plain text or HTML. - <code>tuple</code>: Allows returning body, status code, and headers together. - <code>Response</code>: Built-in response classes for more control.</p>"},{"location":"response/#automated-response-detection","title":"Automated Response Detection","text":"<p>Ignyx is smart about what you return:</p> <ul> <li>JSON: If you return a <code>dict</code> or <code>list</code>, Ignyx sets <code>Content-Type: application/json</code>.</li> <li>HTML: If you return a <code>str</code> that starts with <code>&lt;</code> (after stripping whitespace), Ignyx assumes it's HTML and sets <code>Content-Type: text/html</code>.</li> <li>Text: Otherwise, a <code>str</code> is returned as <code>application/json</code> (wrapped string) or you can use <code>PlainTextResponse</code>.</li> </ul>"},{"location":"response/#jsonresponse","title":"JSONResponse","text":"<p>Use <code>JSONResponse</code> for explicit JSON responses with custom status codes.</p> <pre><code>from ignyx.responses import JSONResponse\n\n@app.get(\"/items/{id}\")\ndef read_item(id: int):\n    if id == 0:\n        return JSONResponse({\"error\": \"Invalid ID\"}, status_code=400)\n    return {\"id\": id, \"name\": \"Item\"}\n</code></pre>"},{"location":"response/#htmlresponse","title":"HTMLResponse","text":"<p>Return raw HTML content.</p> <pre><code>from ignyx.responses import HTMLResponse\n\n@app.get(\"/welcome\")\ndef welcome():\n    return HTMLResponse(\"&lt;h1&gt;Welcome to Ignyx!&lt;/h1&gt;\")\n</code></pre>"},{"location":"response/#plaintextresponse","title":"PlainTextResponse","text":"<p>Return a plain text response.</p> <pre><code>from ignyx.responses import PlainTextResponse\n\n@app.get(\"/robots.txt\")\ndef robots():\n    return PlainTextResponse(\"User-agent: *\\nDisallow: /\")\n</code></pre>"},{"location":"response/#redirectresponse","title":"RedirectResponse","text":"<p>Perform HTTP redirects.</p> <pre><code>from ignyx.responses import RedirectResponse\n\n@app.get(\"/old-path\")\ndef old_path():\n    return RedirectResponse(\"/new-path\", status_code=301)\n</code></pre>"},{"location":"response/#fileresponse","title":"FileResponse","text":"<p>Serve files for download. Ignyx handles this efficiently from the Rust core.</p> <pre><code>from ignyx.responses import FileResponse\n\n@app.get(\"/download\")\ndef download():\n    return FileResponse(\"path/to/report.pdf\", filename=\"UserReport.pdf\")\n</code></pre> <p>Note: Large files (&gt;10MB) are currently buffered; streaming support is in development.</p>"},{"location":"response/#tuple-syntax","title":"Tuple Syntax","text":"<p>For convenience, you can return a tuple to specify status and headers without importing response classes.</p> <pre><code>@app.get(\"/simple\")\ndef simple():\n    # body, status_code\n    return {\"ok\": True}, 201\n\n@app.post(\"/custom\")\ndef custom():\n    # body, status_code, headers_dict\n    return \"Created\", 201, {\"X-Header\": \"Ignyx\"}\n</code></pre>"},{"location":"response/#cookies","title":"Cookies","text":"<p>You can set cookies using the <code>set_cookie</code> method on response objects.</p> <pre><code>from ignyx.responses import JSONResponse\n\n@app.post(\"/login\")\ndef login():\n    response = JSONResponse({\"message\": \"Logged in\"})\n    response.set_cookie(\"session_id\", \"abc-123\", max_age=3600, httponly=True)\n    return response\n</code></pre> <p>Parameters for <code>set_cookie</code>: - <code>key</code>: Cookie name. - <code>value</code>: Cookie value. - <code>max_age</code>: Lifetime in seconds. - <code>path</code>: Cookie path (default: <code>/</code>). - <code>domain</code>: Cookie domain. - <code>secure</code>: HTTPS only (default: <code>False</code>). - <code>httponly</code>: Prevents JS access (default: <code>False</code>). - <code>samesite</code>: CSRF protection (<code>\"Strict\"</code>, <code>\"Lax\"</code>, or <code>\"None\"</code>).</p>"},{"location":"routing/","title":"Routing","text":"<p>Routing in Ignyx is handled by a high-performance Radix Tree router implemented in Rust using the <code>matchit</code> crate. It supports path parameters, query parameters, and modular routing via <code>Router</code> prefixes.</p>"},{"location":"routing/#overview","title":"Overview","text":"<p>Routes are defined using decorators on your <code>Ignyx</code> app instance or a <code>Router</code> instance. Ignyx uses the function signature to determine which parameters to inject (path params, query params, request object, etc.).</p>"},{"location":"routing/#path-parameters-with-types","title":"Path Parameters with Types","text":"<p>You can capture values from the URL using curly braces. Ignyx supports type coercion for common types.</p> <pre><code>@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int):\n    # user_id is automatically converted to an int\n    return {\"id\": user_id}\n\n@app.get(\"/files/{file_path}\")\ndef get_file(file_path: str):\n    return {\"path\": file_path}\n</code></pre>"},{"location":"routing/#query-parameters","title":"Query Parameters","text":"<p>Any function parameter that is not a path parameter and not a complex type (like <code>Request</code> or a Pydantic model) is treated as a query parameter.</p> <pre><code>@app.get(\"/items\")\ndef search_items(q: str, limit: int = 10, offset: int = 0):\n    return {\n        \"query\": q,\n        \"limit\": limit,\n        \"offset\": offset\n    }\n</code></pre>"},{"location":"routing/#router-prefix-include","title":"Router: Prefix + Include","text":"<p>For larger applications, you can organize your routes into multiple files using the <code>Router</code> class.</p> <p>users_router.py:</p> <pre><code>from ignyx import Router\n\nrouter = Router()\n\n@router.get(\"/\")\ndef list_users():\n    return [{\"id\": 1}]\n\n@router.get(\"/{id}\")\ndef get_user(id: int):\n    return {\"id\": id}\n</code></pre> <p>app.py:</p> <pre><code>from ignyx import Ignyx\nfrom .users_router import router as users_router\n\napp = Ignyx()\napp.include_router(users_router, prefix=\"/users\")\n</code></pre>"},{"location":"routing/#http-methods","title":"HTTP Methods","text":"<p>Ignyx supports all standard HTTP methods:</p> <pre><code>@app.get(\"/\")\ndef read(): ...\n\n@app.post(\"/\")\ndef create(): ...\n\n@app.put(\"/\")\ndef update(): ...\n\n@app.delete(\"/\")\ndef delete(): ...\n\n@app.patch(\"/\")\ndef patch(): ...\n</code></pre>"},{"location":"routing/#404-handling","title":"404 Handling","text":"<p>You can customize the 404 Not Found response using the <code>exception_handler</code> decorator.</p> <pre><code>from ignyx import Ignyx, JSONResponse\n\napp = Ignyx()\n\n@app.exception_handler(404)\ndef custom_404(request, exc):\n    return JSONResponse(\n        {\"error\": \"Custom Not Found\", \"path\": request.path},\n        status_code=404\n    )\n</code></pre>"},{"location":"routing/#api-reference","title":"API Reference","text":""},{"location":"routing/#appgetpath-apppostpath-etc","title":"<code>app.get(path)</code>, <code>app.post(path)</code>, etc.","text":"<p>Decorators for registering routes.</p>"},{"location":"routing/#appinclude_routerrouter-prefix","title":"<code>app.include_router(router, prefix=\"\")</code>","text":"<p>Integrates a <code>Router</code> instance into the application.</p>"},{"location":"routing/#router","title":"<code>Router()</code>","text":"<p>Class for creating modular groups of routes.</p>"},{"location":"security/","title":"Security","text":"<p>Ignyx includes several utilities to help you secure your API endpoints with common authentication schemes like OAuth2, API Keys, and HTTP Basic authentication.</p>"},{"location":"security/#overview","title":"Overview","text":"<p>Security utilities in Ignyx are designed to be used with the <code>Depends()</code> pattern. They extract credentials from the request (headers, cookies, or query params) and can be used to authenticate users before the route handler is executed.</p>"},{"location":"security/#oauth2passwordbearer","title":"OAuth2PasswordBearer","text":"<p>This utility extracts a Bearer token from the <code>Authorization</code> header.</p> <pre><code>from ignyx import Ignyx, Depends\nfrom ignyx.security import OAuth2PasswordBearer\n\napp = Ignyx()\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n@app.get(\"/items\")\ndef read_items(token: str = Depends(oauth2_scheme)):\n    return {\"token\": token}\n</code></pre>"},{"location":"security/#apikeyheader","title":"APIKeyHeader","text":"<p>Extract an API key from a custom header.</p> <pre><code>from ignyx.security import APIKeyHeader\n\napi_key_header = APIKeyHeader(name=\"X-API-Key\")\n\n@app.get(\"/secure-data\")\ndef get_secure_data(api_key: str = Depends(api_key_header)):\n    if api_key != \"secret-key\":\n        raise HTTPException(403, \"Invalid API Key\")\n    return {\"data\": \"highly-sensitive\"}\n</code></pre>"},{"location":"security/#httpbasic","title":"HTTPBasic","text":"<p>Standard HTTP Basic authentication (Username/Password).</p> <pre><code>from ignyx.security import HTTPBasic\n\nsecurity = HTTPBasic()\n\n@app.get(\"/admin\")\ndef admin_panel(credentials = Depends(security)):\n    # credentials has .username and .password\n    return {\"admin\": credentials.username}\n</code></pre>"},{"location":"security/#using-with-depends","title":"Using with Depends()","text":"<p>You typically wrap these security schemes in a higher-level dependency to fetch user data from a database.</p> <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)):\n    user = db.fetch_user_by_token(token)\n    if not user:\n        raise HTTPException(401, \"Invalid credentials\")\n    return user\n\n@app.get(\"/me\")\ndef me(user = Depends(get_current_user)):\n    return user\n</code></pre>"},{"location":"security/#production-https-note","title":"Production HTTPS Note","text":"<p>In production, you should always run your Ignyx application behind a TLS/SSL proxy (like Nginx, Caddy, or a Cloud Load Balancer) to ensure that credentials sent via headers are encrypted.</p>"},{"location":"security/#api-reference","title":"API Reference","text":""},{"location":"security/#oauth2passwordbearertokenurl","title":"<code>OAuth2PasswordBearer(tokenUrl)</code>","text":"<p>Extracts Bearer token from <code>Authorization</code> header.</p>"},{"location":"security/#apikeyheadername","title":"<code>APIKeyHeader(name)</code>","text":"<p>Extracts value from the specified header.</p>"},{"location":"security/#httpbasic_1","title":"<code>HTTPBasic()</code>","text":"<p>Extracts and decodes Basic credentials.</p>"},{"location":"static_files/","title":"Static Files","text":"<p>Ignyx provides a high-performance way to serve static assets like images, CSS, and JavaScript files using the <code>StaticFiles</code> class.</p>"},{"location":"static_files/#overview","title":"Overview","text":"<p>Serving static files in Ignyx is handled by mounting a <code>StaticFiles</code> instance to a specific path prefix. The file serving logic is implemented in Rust, ensuring minimal overhead and zero-copy transfers when possible.</p>"},{"location":"static_files/#basic-usage","title":"Basic Usage","text":"<p>Mount a directory to a path like <code>/static</code>.</p> <pre><code>from ignyx import Ignyx\nfrom ignyx.staticfiles import StaticFiles\n\napp = Ignyx()\n\n# Files in the \"static\" directory will be available at /static/*\napp.mount(\"/static\", StaticFiles(directory=\"static\"))\n</code></pre> <p>If you have a file <code>static/logo.png</code>, it will be accessible at <code>http://localhost:8000/static/logo.png</code>.</p>"},{"location":"static_files/#serving-a-single-page-application-spa","title":"Serving a Single Page Application (SPA)","text":"<p>If you are serving a modern frontend framework like React or Vue, you can enable <code>html=True</code> to serve an <code>index.html</code> file when a directory is requested.</p> <pre><code>app.mount(\"/\", StaticFiles(directory=\"dist\", html=True))\n</code></pre> <p>This is useful for professional production deployments where the backend serves the frontend assets directly.</p>"},{"location":"static_files/#mime-type-auto-detection","title":"MIME Type Auto-Detection","text":"<p>Ignyx automatically detects the correct <code>Content-Type</code> header for common file extensions based on your operating system's MIME database.</p> <ul> <li><code>.html</code> -&gt; <code>text/html</code></li> <li><code>.css</code> -&gt; <code>text/css</code></li> <li><code>.js</code> -&gt; <code>application/javascript</code></li> <li><code>.png</code> -&gt; <code>image/png</code></li> <li><code>.json</code> -&gt; <code>application/json</code></li> </ul>"},{"location":"static_files/#security","title":"Security","text":"<p>Ignyx includes built-in protection against path traversal attacks. It ensures that requests cannot access files outside of the specified <code>directory</code> by normalizing paths and checking boundaries before reading any data.</p>"},{"location":"static_files/#api-reference","title":"API Reference","text":""},{"location":"static_files/#staticfilesdirectory-htmlfalse","title":"<code>StaticFiles(directory, html=False)</code>","text":"<ul> <li><code>directory</code>: The local directory to serve files from.</li> <li><code>html</code>: If <code>True</code>, automatically looks for <code>index.html</code> in directories and supports sub-path routing for SPAs.</li> </ul>"},{"location":"testing/","title":"Testing","text":"<p>Ignyx provides a <code>TestClient</code> that allows you to test your application without starting a real HTTP server. This makes your tests significantly faster and easier to run in CI/CD environments.</p>"},{"location":"testing/#overview","title":"Overview","text":"<p>The <code>TestClient</code> uses an internal dispatch mechanism to call your route handlers directly, bypassing the network stack while still executing all middleware and dependency injection logic.</p>"},{"location":"testing/#basic-example","title":"Basic Example","text":"<p>Use the <code>TestClient</code> to verify the response of a simple GET route.</p> <pre><code>from ignyx import Ignyx\nfrom ignyx.testclient import TestClient\n\napp = Ignyx()\n\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"ok\"}\n\ndef test_health():\n    client = TestClient(app)\n    response = client.get(\"/health\")\n    assert response.status_code == 200\n    assert response.json() == {\"status\": \"ok\"}\n</code></pre>"},{"location":"testing/#testing-post-with-json-body","title":"Testing POST with JSON Body","text":"<p>Pass data to the <code>json</code> parameter to send a JSON-encoded body.</p> <pre><code>def test_create_user():\n    client = TestClient(app)\n    payload = {\"name\": \"Saketh\", \"age\": 25}\n    response = client.post(\"/users\", json=payload)\n    assert response.status_code == 201\n    assert response.json()[\"name\"] == \"Saketh\"\n</code></pre>"},{"location":"testing/#testing-file-uploads","title":"Testing File Uploads","text":"<p>You can test multipart file uploads by passing a dictionary to the <code>files</code> parameter.</p> <pre><code>def test_upload():\n    client = TestClient(app)\n    files = {\"file\": (\"test.txt\", b\"hello world\", \"text/plain\")}\n    response = client.post(\"/upload\", files=files)\n    assert response.status_code == 200\n</code></pre>"},{"location":"testing/#overriding-dependencies","title":"Overriding Dependencies","text":"<p>One of the most powerful features of the <code>TestClient</code> is the ability to override dependencies during tests.</p> <pre><code>def get_db():\n    return real_db_connection\n\ndef test_with_mock_db():\n    def mock_db():\n        return {\"data\": \"mocked\"}\n\n    app.dependency_overrides[get_db] = mock_db\n    client = TestClient(app)\n\n    response = client.get(\"/data\")\n    assert response.json()[\"data\"] == \"mocked\"\n</code></pre>"},{"location":"testing/#testing-websockets","title":"Testing WebSockets","text":"<p>The <code>TestClient</code> also supports testing WebSockets using a context manager.</p> <pre><code>def test_websocket():\n    client = TestClient(app)\n    with client.websocket_connect(\"/ws\") as ws:\n        ws.send_text(\"Hello\")\n        data = ws.receive_text()\n        assert data == \"Echo: Hello\"\n</code></pre>"},{"location":"testing/#api-reference","title":"API Reference","text":""},{"location":"testing/#testclientapp","title":"<code>TestClient(app)</code>","text":"<p>Initialize the test client with your Ignyx app.</p>"},{"location":"testing/#clientgeturl-headersnone-cookiesnone","title":"<code>client.get(url, headers=None, cookies=None)</code>","text":"<p>Send a GET request.</p>"},{"location":"testing/#clientposturl-jsonnone-datanone-filesnone-headersnone-cookiesnone","title":"<code>client.post(url, json=None, data=None, files=None, headers=None, cookies=None)</code>","text":"<p>Send a POST request.</p>"},{"location":"testing/#clientwebsocket_connecturl","title":"<code>client.websocket_connect(url)</code>","text":"<p>Connect to a WebSocket endpoint. Returns a context manager.</p>"},{"location":"validation/","title":"Validation","text":"<p>Ignyx leverages the power of Pydantic v2 for high-speed data validation and schema enforcement. This allows you to define the structure of your data once and have Ignyx handle the validation and parsing automatically.</p>"},{"location":"validation/#overview","title":"Overview","text":"<p>When you type-hint a route handler parameter with a Pydantic <code>BaseModel</code>, Ignyx automatically: 1. Reads the request body. 2. Validates the data against the model. 3. Returns a <code>422 Unprocessable Entity</code> response if validation fails. 4. Passes the parsed model instance to your handler.</p>"},{"location":"validation/#basic-example","title":"Basic Example","text":"<p>Define a model and use it in your route.</p> <pre><code>from pydantic import BaseModel\nfrom ignyx import Ignyx\n\napp = Ignyx()\n\nclass User(BaseModel):\n    name: str\n    age: int\n\n@app.post(\"/users\")\ndef create_user(user: User):\n    return {\"message\": f\"Hello {user.name}, you are {user.age}!\"}\n</code></pre>"},{"location":"validation/#nested-models","title":"Nested Models","text":"<p>You can nest models to represent complex data structures.</p> <pre><code>class Address(BaseModel):\n    city: str\n    country: str\n\nclass Profile(BaseModel):\n    username: str\n    address: Address\n\n@app.post(\"/profile\")\ndef update_profile(profile: Profile):\n    return {\"city\": profile.address.city}\n</code></pre>"},{"location":"validation/#optional-fields","title":"Optional Fields","text":"<p>Use Python's type system to define optional fields.</p> <pre><code>from typing import Optional\n\nclass Item(BaseModel):\n    name: str\n    description: Optional[str] = None # Or use name: str | None = None\n    price: float\n</code></pre>"},{"location":"validation/#validation-errors","title":"Validation Errors","text":"<p>If a client sends invalid data, Ignyx automatically returns a structured <code>422</code> error response.</p> <p>Request:</p> <pre><code>{\n    \"name\": \"Saketh\",\n    \"age\": \"invalid_age\"\n}\n</code></pre> <p>Response (422):</p> <pre><code>{\n    \"detail\": [\n        {\n            \"loc\": [\"body\", \"age\"],\n            \"msg\": \"Input should be a valid integer\",\n            \"type\": \"int_parsing\"\n        }\n    ]\n}\n</code></pre>"},{"location":"validation/#field-validators","title":"Field Validators","text":"<p>You can add custom validation logic using Pydantic's <code>@field_validator</code>.</p> <pre><code>from pydantic import BaseModel, field_validator\n\nclass Signup(BaseModel):\n    username: str\n    password: str\n\n    @field_validator('username')\n    @classmethod\n    def username_must_be_long(cls, v: str) -&gt; str:\n        if len(v) &lt; 3:\n            raise ValueError('Username is too short')\n        return v\n</code></pre>"},{"location":"validation/#api-reference","title":"API Reference","text":"<p>Ignyx supports any Pydantic <code>BaseModel</code>. For full documentation on model features, see the Pydantic Documentation.</p>"},{"location":"websockets/","title":"WebSockets","text":"<p>WebSockets in Ignyx provide full bidirectional, full-duplex communication between the client and the server. Built on top of the high-performance Rust <code>tokio-tungstenite</code> library, Ignyx WebSockets are incredibly fast and efficient.</p>"},{"location":"websockets/#overview","title":"Overview","text":"<p>Unlike standard HTTP requests, WebSockets maintain a persistent connection, allowing both parties to send data at any time. This is ideal for real-time applications like chat servers, live dashboards, and multiplayer games.</p>"},{"location":"websockets/#basic-example-echo-server","title":"Basic Example: Echo Server","text":"<p>Creating a WebSocket endpoint is simple. You use the <code>@app.websocket</code> decorator and an <code>async def</code> function.</p> <pre><code>from ignyx import Ignyx\n\napp = Ignyx()\n\n@app.websocket(\"/ws\")\nasync def websocket_endpoint(ws):\n    await ws.accept()\n    while True:\n        try:\n            data = await ws.receive_text()\n            await ws.send_text(f\"Echo: {data}\")\n        except Exception:\n            # Handle disconnection\n            break\n</code></pre>"},{"location":"websockets/#advanced-example-chat-room","title":"Advanced Example: Chat Room","text":"<p>You can manage multiple connections using a simple dictionary or list.</p> <pre><code>from ignyx import Ignyx\n\napp = Ignyx()\nconnected_clients = set()\n\n@app.websocket(\"/chat\")\nasync def chat_room(ws):\n    await ws.accept()\n    connected_clients.add(ws)\n    try:\n        while True:\n            msg = await ws.receive_text()\n            # Broadcast to all connected clients\n            for client in connected_clients:\n                await client.send_text(f\"User: {msg}\")\n    except Exception:\n        pass\n    finally:\n        connected_clients.remove(ws)\n</code></pre>"},{"location":"websockets/#sending-json","title":"Sending JSON","text":"<p>Ignyx makes it easy to work with structured data over WebSockets using JSON.</p> <pre><code>@app.websocket(\"/notifications\")\nasync def notifications(ws):\n    await ws.accept()\n    # Sending a JSON object\n    await ws.send_json({\"type\": \"info\", \"message\": \"Welcome to the real-time era!\"})\n\n    # Receiving JSON\n    data = await ws.receive_json()\n    print(f\"Received JSON: {data['content']}\")\n</code></pre>"},{"location":"websockets/#closing","title":"Closing","text":"<p>You can close a connection gracefully at any time.</p> <pre><code>@app.websocket(\"/once\")\nasync def once(ws):\n    await ws.accept()\n    await ws.send_text(\"Goodbye!\")\n    await ws.close(code=1000)\n</code></pre>"},{"location":"websockets/#error-handling","title":"Error Handling","text":"<p>Always wrap your communication loop in a <code>try/except</code> block to detect when a client disconnects.</p> <pre><code>@app.websocket(\"/safe\")\nasync def safe_ws(ws):\n    await ws.accept()\n    try:\n        while True:\n            data = await ws.receive_text()\n            # process data\n    except Exception as e:\n        print(f\"Client disconnected or error occurred: {e}\")\n</code></pre>"},{"location":"websockets/#api-reference","title":"API Reference","text":""},{"location":"websockets/#wsaccept","title":"<code>ws.accept()</code>","text":"<p>Accepts the incoming WebSocket connection. This must be called before sending or receiving data.</p>"},{"location":"websockets/#await-wsreceive_text","title":"<code>await ws.receive_text()</code>","text":"<p>Wait for a text message from the client. Returns a <code>str</code>.</p>"},{"location":"websockets/#await-wsreceive_json","title":"<code>await ws.receive_json()</code>","text":"<p>Wait for a text message and parse it as JSON. Returns a <code>dict</code> or <code>list</code>.</p>"},{"location":"websockets/#await-wssend_textdata","title":"<code>await ws.send_text(data)</code>","text":"<p>Send a string message to the client.</p>"},{"location":"websockets/#await-wssend_jsondata","title":"<code>await ws.send_json(data)</code>","text":"<p>Serialize the data and send it as a JSON string message.</p>"},{"location":"websockets/#await-wsclosecode1000","title":"<code>await ws.close(code=1000)</code>","text":"<p>Close the connection with the specified status code.</p>"}]}